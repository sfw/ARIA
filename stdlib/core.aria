# ARIA Standard Library - Core Module
# Provides fundamental utilities for error handling and assertions

# ============================================================
# Option helpers
# ============================================================

# Map a function over an Option value
# If Some(x), returns Some(f(x)); if None, returns None
f option_map(opt: Option[Int], mapper: |Int| -> Int) -> Option[Int]
    m opt
        Some(v) -> Some(mapper(v))
        None -> None

# Flat map (bind) for Option
# If Some(x), returns f(x); if None, returns None
f option_flat_map(opt: Option[Int], mapper: |Int| -> Option[Int]) -> Option[Int]
    m opt
        Some(v) -> mapper(v)
        None -> None

# Get value from Option or return default
f option_unwrap_or(opt: Option[Int], default: Int) -> Int
    m opt
        Some(v) -> v
        None -> default

# Check if Option is Some
f option_is_some(opt: Option[Int]) -> Bool
    m opt
        Some(_) -> true
        None -> false

# Check if Option is None
f option_is_none(opt: Option[Int]) -> Bool
    m opt
        Some(_) -> false
        None -> true

# ============================================================
# Result helpers
# ============================================================

# Map a function over a Result's Ok value
f result_map(res: Result[Int, Str], mapper: |Int| -> Int) -> Result[Int, Str]
    m res
        Ok(v) -> Ok(mapper(v))
        Err(e) -> Err(e)

# Map a function over a Result's Err value
f result_map_err(res: Result[Int, Str], mapper: |Str| -> Str) -> Result[Int, Str]
    m res
        Ok(v) -> Ok(v)
        Err(e) -> Err(mapper(e))

# Get value from Result or return default
f result_unwrap_or(res: Result[Int, Str], default: Int) -> Int
    m res
        Ok(v) -> v
        Err(_) -> default

# Check if Result is Ok
f result_is_ok(res: Result[Int, Str]) -> Bool
    m res
        Ok(_) -> true
        Err(_) -> false

# Check if Result is Err
f result_is_err(res: Result[Int, Str]) -> Bool
    m res
        Ok(_) -> false
        Err(_) -> true

# Convert Option to Result with error message
f option_ok_or(opt: Option[Int], err: Str) -> Result[Int, Str]
    m opt
        Some(v) -> Ok(v)
        None -> Err(err)

# ============================================================
# Assertion helpers
# ============================================================

# Assert that two integers are equal
f assert_eq(actual: Int, expected: Int, msg: Str) -> Bool
    if actual == expected then true
    else
        print("Assertion failed:")
        print(msg)
        print("Expected:")
        print(expected)
        print("Actual:")
        print(actual)
        false

# Assert that two strings are equal
f assert_str_eq(actual: Str, expected: Str, msg: Str) -> Bool
    if actual == expected then true
    else
        print("Assertion failed:")
        print(msg)
        print("Expected:")
        print(expected)
        print("Actual:")
        print(actual)
        false

# Assert that a boolean is true
f assert_true(cond: Bool, msg: Str) -> Bool
    if cond then true
    else
        print("Assertion failed:")
        print(msg)
        false

# Assert that a boolean is false
f assert_false(cond: Bool, msg: Str) -> Bool
    if !cond then true
    else
        print("Assertion failed (expected false):")
        print(msg)
        false

# ============================================================
# Numeric utilities
# ============================================================

# Absolute value
f abs(n: Int) -> Int
    if n < 0 then 0 - n else n

# Minimum of two integers
f min(a: Int, b: Int) -> Int
    if a < b then a else b

# Maximum of two integers
f max(a: Int, b: Int) -> Int
    if a > b then a else b

# Clamp a value between min and max
f clamp(value: Int, min_val: Int, max_val: Int) -> Int
    if value < min_val then min_val
    else if value > max_val then max_val
    else value

# Sign of an integer: -1, 0, or 1
f sign(n: Int) -> Int
    if n < 0 then 0 - 1
    else if n > 0 then 1
    else 0
