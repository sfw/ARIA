# ARIA Bootstrap Compiler - Combined File for Testing
# This file combines token.aria, ast.aria, parser.aria, and type_checker.aria

# ============================================================
# Token Kinds
# ============================================================

s TokenKind
    kind: Int
    int_value: Int
    float_value: Float
    str_value: Str
    char_value: Char

f TK_F() -> Int = 1
f TK_S() -> Int = 2
f TK_E() -> Int = 3
f TK_T() -> Int = 4
f TK_I() -> Int = 5
f TK_M() -> Int = 6

f TK_IF() -> Int = 10
f TK_THEN() -> Int = 11
f TK_ELSE() -> Int = 12
f TK_FOR() -> Int = 13
f TK_IN() -> Int = 14
f TK_WH() -> Int = 15
f TK_LP() -> Int = 16
f TK_BR() -> Int = 17
f TK_CT() -> Int = 18
f TK_RET() -> Int = 19
f TK_AS() -> Int = 20
f TK_AW() -> Int = 21
f TK_US() -> Int = 22
f TK_MD() -> Int = 23
f TK_PUB() -> Int = 24
f TK_MUT() -> Int = 25
f TK_MV() -> Int = 26
f TK_UN() -> Int = 27
f TK_TYPE() -> Int = 28
f TK_WHERE() -> Int = 29

f TK_TRUE() -> Int = 40
f TK_FALSE() -> Int = 41
f TK_NONE() -> Int = 42

f TK_SOME() -> Int = 45
f TK_OK() -> Int = 46
f TK_ERR() -> Int = 47

f TK_PLUS() -> Int = 50
f TK_MINUS() -> Int = 51
f TK_STAR() -> Int = 52
f TK_SLASH() -> Int = 53
f TK_PERCENT() -> Int = 54

f TK_EQEQ() -> Int = 60
f TK_BANGEQ() -> Int = 61
f TK_LT() -> Int = 62
f TK_LTEQ() -> Int = 63
f TK_GT() -> Int = 64
f TK_GTEQ() -> Int = 65

f TK_AMPAMP() -> Int = 70
f TK_PIPEPIPE() -> Int = 71
f TK_BANG() -> Int = 72

f TK_AMP() -> Int = 75
f TK_PIPE() -> Int = 76
f TK_CARET() -> Int = 77
f TK_LTLT() -> Int = 78
f TK_GTGT() -> Int = 79

f TK_EQ() -> Int = 80
f TK_COLONEQ() -> Int = 81
f TK_PLUSEQ() -> Int = 82
f TK_MINUSEQ() -> Int = 83
f TK_STAREQ() -> Int = 84
f TK_SLASHEQ() -> Int = 85

f TK_QUESTION() -> Int = 90
f TK_QUESTIONQUESTION() -> Int = 91
f TK_ARROW() -> Int = 92
f TK_FATARROW() -> Int = 93
f TK_DOTDOT() -> Int = 94
f TK_DOTDOTEQ() -> Int = 95
f TK_COLONCOLON() -> Int = 96
f TK_DOT() -> Int = 97
f TK_COMMA() -> Int = 98
f TK_AT() -> Int = 99

f TK_LPAREN() -> Int = 100
f TK_RPAREN() -> Int = 101
f TK_LBRACKET() -> Int = 102
f TK_RBRACKET() -> Int = 103
f TK_LBRACE() -> Int = 104
f TK_RBRACE() -> Int = 105
f TK_COLON() -> Int = 106
f TK_SEMICOLON() -> Int = 107

f TK_INT() -> Int = 110
f TK_FLOAT() -> Int = 111
f TK_STRING() -> Int = 112
f TK_CHAR() -> Int = 113

f TK_IDENT() -> Int = 120

f TK_NEWLINE() -> Int = 130
f TK_INDENT() -> Int = 131
f TK_DEDENT() -> Int = 132

f TK_EOF() -> Int = 140
f TK_ERROR() -> Int = 141

# ============================================================
# Span
# ============================================================

s Span
    start: Int
    end: Int
    line: Int
    column: Int

f span_new(start: Int, end: Int, line: Int, column: Int) -> Span
    Span { start: start, end: end, line: line, column: column }

f span_len(span: Span) -> Int = span.end - span.start

f span_merge(a: Span, b: Span) -> Span
    Span { start: a.start, end: b.end, line: a.line, column: a.column }

# ============================================================
# Token
# ============================================================

s Token
    kind: Int
    span: Span
    lexeme: Str
    int_val: Int
    float_val: Float
    str_val: Str
    char_val: Char

f token_new(kind: Int, span: Span, lexeme: Str) -> Token
    Token { kind: kind, span: span, lexeme: lexeme, int_val: 0, float_val: 0.0, str_val: "", char_val: ' ' }

f token_is(tok: Token, kind: Int) -> Bool
    tok.kind == kind

# ============================================================
# Expression Kinds
# ============================================================

f EXPR_INT() -> Int = 1
f EXPR_FLOAT() -> Int = 2
f EXPR_BOOL() -> Int = 3
f EXPR_CHAR() -> Int = 4
f EXPR_STR() -> Int = 5

f EXPR_IDENT() -> Int = 10
f EXPR_PATH() -> Int = 11

f EXPR_BINARY() -> Int = 20
f EXPR_UNARY() -> Int = 21

f EXPR_CALL() -> Int = 30
f EXPR_METHOD_CALL() -> Int = 31
f EXPR_FIELD() -> Int = 32
f EXPR_INDEX() -> Int = 33

f EXPR_TUPLE() -> Int = 40
f EXPR_ARRAY() -> Int = 41
f EXPR_STRUCT() -> Int = 42

f EXPR_IF() -> Int = 50
f EXPR_MATCH() -> Int = 51
f EXPR_WHILE() -> Int = 52
f EXPR_FOR() -> Int = 53
f EXPR_LOOP() -> Int = 54
f EXPR_BLOCK() -> Int = 55

f EXPR_RETURN() -> Int = 60
f EXPR_BREAK() -> Int = 61
f EXPR_CONTINUE() -> Int = 62

f EXPR_CLOSURE() -> Int = 70

f EXPR_ASSIGN() -> Int = 80

# ============================================================
# Expression Node
# ============================================================

s ExprNode
    kind: Int
    span: Span
    int_val: Int
    float_val: Float
    bool_val: Bool
    char_val: Char
    str_val: Str
    name: Str
    left: Int
    op: Int
    right: Int
    operand: Int
    callee: Int
    args: [Int]
    object: Int
    field: Str
    elements: [Int]
    condition: Int
    then_branch: Int
    else_branch: Int
    scrutinee: Int
    arms: [Int]
    body_block: Int
    stmts: [Int]
    type_name: Str
    field_inits: [(Str, Int)]

f expr_new(kind: Int, span: Span) -> ExprNode
    ExprNode {
        kind: kind,
        span: span,
        int_val: 0,
        float_val: 0.0,
        bool_val: false,
        char_val: ' ',
        str_val: "",
        name: "",
        left: -1,
        op: 0,
        right: -1,
        operand: -1,
        callee: -1,
        args: [],
        object: -1,
        field: "",
        elements: [],
        condition: -1,
        then_branch: -1,
        else_branch: -1,
        scrutinee: -1,
        arms: [],
        body_block: -1,
        stmts: [],
        type_name: "",
        field_inits: []
    }

# ============================================================
# Statement and Item Kinds
# ============================================================

f STMT_EXPR() -> Int = 1
f STMT_LET() -> Int = 2
f STMT_ITEM() -> Int = 3

s StmtNode
    kind: Int
    span: Span
    expr: Int
    pattern: Int
    init: Int
    mutable: Bool
    item: Int

f stmt_new(kind: Int, span: Span) -> StmtNode
    StmtNode {
        kind: kind,
        span: span,
        expr: -1,
        pattern: -1,
        init: -1,
        mutable: false,
        item: -1
    }

f ITEM_FN() -> Int = 1
f ITEM_STRUCT() -> Int = 2
f ITEM_ENUM() -> Int = 3

s ItemNode
    kind: Int
    span: Span
    name: Str
    params: [(Str, Int)]
    return_type: Int
    body: Int
    fields: [(Str, Int)]
    variants: [(Str, [Int])]

f item_new(kind: Int, span: Span, name: Str) -> ItemNode
    ItemNode {
        kind: kind,
        span: span,
        name: name,
        params: [],
        return_type: -1,
        body: -1,
        fields: [],
        variants: []
    }

# ============================================================
# Type Kinds
# ============================================================

f TYPE_NAMED() -> Int = 1
f TYPE_TUPLE() -> Int = 2
f TYPE_ARRAY() -> Int = 3
f TYPE_OPTION() -> Int = 4
f TYPE_RESULT() -> Int = 5
f TYPE_FN() -> Int = 6

s TypeNode
    kind: Int
    span: Span
    name: Str
    elements: [Int]
    inner: Int
    error: Int

f type_node_new(kind: Int, span: Span) -> TypeNode
    TypeNode {
        kind: kind,
        span: span,
        name: "",
        elements: [],
        inner: -1,
        error: -1
    }

# ============================================================
# Pattern Kinds
# ============================================================

f PAT_WILDCARD() -> Int = 1
f PAT_IDENT() -> Int = 2
f PAT_LITERAL() -> Int = 3
f PAT_TUPLE() -> Int = 4
f PAT_STRUCT() -> Int = 5

s PatternNode
    kind: Int
    span: Span
    name: Str
    mutable: Bool
    literal: Int
    elements: [Int]
    fields: [(Str, Int)]

f pattern_new(kind: Int, span: Span) -> PatternNode
    PatternNode {
        kind: kind,
        span: span,
        name: "",
        mutable: false,
        literal: -1,
        elements: [],
        fields: []
    }

# ============================================================
# Match Arm
# ============================================================

s MatchArm
    pattern: Int
    guard: Int
    body: Int
    span: Span

f match_arm_new(pattern: Int, body: Int, span: Span) -> MatchArm
    MatchArm {
        pattern: pattern,
        guard: -1,
        body: body,
        span: span
    }

# ============================================================
# Binary Operators
# ============================================================

f OP_ADD() -> Int = 1
f OP_SUB() -> Int = 2
f OP_MUL() -> Int = 3
f OP_DIV() -> Int = 4
f OP_REM() -> Int = 5
f OP_EQ() -> Int = 10
f OP_NE() -> Int = 11
f OP_LT() -> Int = 12
f OP_LE() -> Int = 13
f OP_GT() -> Int = 14
f OP_GE() -> Int = 15
f OP_AND() -> Int = 20
f OP_OR() -> Int = 21
f OP_BITAND() -> Int = 30
f OP_BITOR() -> Int = 31
f OP_BITXOR() -> Int = 32
f OP_SHL() -> Int = 33
f OP_SHR() -> Int = 34

f UNOP_NEG() -> Int = 1
f UNOP_NOT() -> Int = 2
f UNOP_REF() -> Int = 3
f UNOP_DEREF() -> Int = 4

# ============================================================
# AST
# ============================================================

s AST
    exprs: [ExprNode]
    stmts: [StmtNode]
    items: [ItemNode]
    types: [TypeNode]
    patterns: [PatternNode]
    match_arms: [MatchArm]
    top_items: [Int]

f ast_new() -> AST
    AST {
        exprs: [],
        stmts: [],
        items: [],
        types: [],
        patterns: [],
        match_arms: [],
        top_items: []
    }

f ast_add_expr(ast: AST, expr: ExprNode) -> (AST, Int)
    idx := vec_len(ast.exprs)
    new_exprs := vec_push(ast.exprs, expr)
    (AST { exprs: new_exprs, stmts: ast.stmts, items: ast.items, types: ast.types, patterns: ast.patterns, match_arms: ast.match_arms, top_items: ast.top_items }, idx)

f ast_add_stmt(ast: AST, stmt: StmtNode) -> (AST, Int)
    idx := vec_len(ast.stmts)
    new_stmts := vec_push(ast.stmts, stmt)
    (AST { exprs: ast.exprs, stmts: new_stmts, items: ast.items, types: ast.types, patterns: ast.patterns, match_arms: ast.match_arms, top_items: ast.top_items }, idx)

f ast_add_item(ast: AST, item: ItemNode) -> (AST, Int)
    idx := vec_len(ast.items)
    new_items := vec_push(ast.items, item)
    (AST { exprs: ast.exprs, stmts: ast.stmts, items: new_items, types: ast.types, patterns: ast.patterns, match_arms: ast.match_arms, top_items: ast.top_items }, idx)

f ast_add_type(ast: AST, ty: TypeNode) -> (AST, Int)
    idx := vec_len(ast.types)
    new_types := vec_push(ast.types, ty)
    (AST { exprs: ast.exprs, stmts: ast.stmts, items: ast.items, types: new_types, patterns: ast.patterns, match_arms: ast.match_arms, top_items: ast.top_items }, idx)

f ast_add_pattern(ast: AST, pat: PatternNode) -> (AST, Int)
    idx := vec_len(ast.patterns)
    new_patterns := vec_push(ast.patterns, pat)
    (AST { exprs: ast.exprs, stmts: ast.stmts, items: ast.items, types: ast.types, patterns: new_patterns, match_arms: ast.match_arms, top_items: ast.top_items }, idx)

f ast_add_match_arm(ast: AST, arm: MatchArm) -> (AST, Int)
    idx := vec_len(ast.match_arms)
    new_arms := vec_push(ast.match_arms, arm)
    (AST { exprs: ast.exprs, stmts: ast.stmts, items: ast.items, types: ast.types, patterns: ast.patterns, match_arms: new_arms, top_items: ast.top_items }, idx)

f ast_add_top_item(ast: AST, idx: Int) -> AST
    new_top := vec_push(ast.top_items, idx)
    AST { exprs: ast.exprs, stmts: ast.stmts, items: ast.items, types: ast.types, patterns: ast.patterns, match_arms: ast.match_arms, top_items: new_top }

# ============================================================================
# Type Checker Types
# ============================================================================

f TY_UNKNOWN() -> Int = 0
f TY_UNIT() -> Int = 1
f TY_INT() -> Int = 2
f TY_FLOAT() -> Int = 3
f TY_BOOL() -> Int = 4
f TY_CHAR() -> Int = 5
f TY_STR() -> Int = 6
f TY_TUPLE() -> Int = 10
f TY_ARRAY() -> Int = 11
f TY_OPTION() -> Int = 12
f TY_RESULT() -> Int = 13
f TY_FN() -> Int = 14
f TY_NAMED() -> Int = 20
f TY_VAR() -> Int = 30

s Type
    kind: Int
    name: Str
    elements: [Int]
    inner: Int
    ok_type: Int
    err_type: Int
    ret_type: Int
    var_id: Int

f type_new(kind: Int) -> Type
    Type {
        kind: kind,
        name: "",
        elements: [],
        inner: -1,
        ok_type: -1,
        err_type: -1,
        ret_type: -1,
        var_id: -1
    }

f ty_unit() -> Type = type_new(TY_UNIT())
f ty_int() -> Type = type_new(TY_INT())
f ty_float() -> Type = type_new(TY_FLOAT())
f ty_bool() -> Type = type_new(TY_BOOL())
f ty_char() -> Type = type_new(TY_CHAR())
f ty_str() -> Type = type_new(TY_STR())
f ty_unknown() -> Type = type_new(TY_UNKNOWN())

f ty_array(inner: Int) -> Type
    t := type_new(TY_ARRAY())
    Type { kind: t.kind, name: t.name, elements: t.elements, inner: inner, ok_type: t.ok_type, err_type: t.err_type, ret_type: t.ret_type, var_id: t.var_id }

f ty_named(name: Str) -> Type
    t := type_new(TY_NAMED())
    Type { kind: t.kind, name: name, elements: t.elements, inner: t.inner, ok_type: t.ok_type, err_type: t.err_type, ret_type: t.ret_type, var_id: t.var_id }

# ============================================================================
# Type Error
# ============================================================================

s TypeError
    message: Str
    span: Span
    expected: Str
    found: Str

f type_error(msg: Str, span: Span) -> TypeError
    TypeError { message: msg, span: span, expected: "", found: "" }

f type_error_mismatch(span: Span, expected: Str, found: Str) -> TypeError
    TypeError { message: "type mismatch", span: span, expected: expected, found: found }

# ============================================================================
# Type Environment
# ============================================================================

s EnvEntry
    name: Str
    type_idx: Int

s FnSig
    name: Str
    param_types: [Int]
    ret_type: Int

s TypeContext
    types: [Type]
    env: [EnvEntry]
    errors: [TypeError]
    fn_env: [FnSig]
    next_var: Int

f ctx_new() -> TypeContext
    types := [ty_unknown(), ty_unit(), ty_int(), ty_float(), ty_bool(), ty_char(), ty_str()]
    TypeContext {
        types: types,
        env: [],
        errors: [],
        fn_env: [],
        next_var: 0
    }

f ctx_add_type(ctx: TypeContext, ty: Type) -> (TypeContext, Int)
    idx := vec_len(ctx.types)
    new_types := vec_push(ctx.types, ty)
    (TypeContext { types: new_types, env: ctx.env, errors: ctx.errors, fn_env: ctx.fn_env, next_var: ctx.next_var }, idx)

f ctx_add_error(ctx: TypeContext, err: TypeError) -> TypeContext
    new_errors := vec_push(ctx.errors, err)
    TypeContext { types: ctx.types, env: ctx.env, errors: new_errors, fn_env: ctx.fn_env, next_var: ctx.next_var }

f ctx_add_var(ctx: TypeContext, name: Str, type_idx: Int) -> TypeContext
    entry := EnvEntry { name: name, type_idx: type_idx }
    new_env := vec_push(ctx.env, entry)
    TypeContext { types: ctx.types, env: new_env, errors: ctx.errors, fn_env: ctx.fn_env, next_var: ctx.next_var }

f ctx_lookup_var(ctx: TypeContext, name: Str) -> Int
    lookup_var_loop(ctx.env, name, vec_len(ctx.env) - 1)

f lookup_var_loop(env: [EnvEntry], name: Str, idx: Int) -> Int
    if idx < 0 then -1
    else
        entry := env[idx]
        if entry.name == name then entry.type_idx
        else lookup_var_loop(env, name, idx - 1)

f ctx_add_fn(ctx: TypeContext, sig: FnSig) -> TypeContext
    new_fn_env := vec_push(ctx.fn_env, sig)
    TypeContext { types: ctx.types, env: ctx.env, errors: ctx.errors, fn_env: new_fn_env, next_var: ctx.next_var }

f ctx_lookup_fn(ctx: TypeContext, name: Str) -> Option[FnSig]
    lookup_fn_loop(ctx.fn_env, name, 0)

f lookup_fn_loop(fns: [FnSig], name: Str, idx: Int) -> Option[FnSig]
    if idx >= vec_len(fns) then None
    else
        sig := fns[idx]
        if sig.name == name then Some(sig)
        else lookup_fn_loop(fns, name, idx + 1)

f IDX_UNKNOWN() -> Int = 0
f IDX_UNIT() -> Int = 1
f IDX_INT() -> Int = 2
f IDX_FLOAT() -> Int = 3
f IDX_BOOL() -> Int = 4
f IDX_CHAR() -> Int = 5
f IDX_STR() -> Int = 6

# ============================================================================
# Type Name and Equality
# ============================================================================

f type_name(ctx: TypeContext, idx: Int) -> Str
    if idx < 0 then "unknown"
    else if idx >= vec_len(ctx.types) then "unknown"
    else
        ty := ctx.types[idx]
        if ty.kind == TY_UNKNOWN() then "unknown"
        else if ty.kind == TY_UNIT() then "()"
        else if ty.kind == TY_INT() then "Int"
        else if ty.kind == TY_FLOAT() then "Float"
        else if ty.kind == TY_BOOL() then "Bool"
        else if ty.kind == TY_CHAR() then "Char"
        else if ty.kind == TY_STR() then "Str"
        else if ty.kind == TY_NAMED() then ty.name
        else if ty.kind == TY_OPTION() then "Option"
        else if ty.kind == TY_ARRAY() then "Array"
        else if ty.kind == TY_FN() then "Fn"
        else "?"

f types_equal(ctx: TypeContext, idx1: Int, idx2: Int) -> Bool
    if idx1 == idx2 then true
    else if idx1 < 0 || idx2 < 0 then false
    else if idx1 >= vec_len(ctx.types) || idx2 >= vec_len(ctx.types) then false
    else types_equal_inner(ctx, idx1, idx2)

f types_equal_inner(ctx: TypeContext, idx1: Int, idx2: Int) -> Bool
    t1 := ctx.types[idx1]
    t2 := ctx.types[idx2]
    if t1.kind != t2.kind then false
    else if t1.kind == TY_NAMED() then t1.name == t2.name
    else if t1.kind == TY_OPTION() || t1.kind == TY_ARRAY() then types_equal(ctx, t1.inner, t2.inner)
    else true

f check_is_bool(ctx: TypeContext, ty: Int, span: Span) -> TypeContext
    if types_equal(ctx, ty, IDX_BOOL()) then ctx
    else ctx_add_error(ctx, type_error_mismatch(span, "Bool", type_name(ctx, ty)))

f check_types_match(ctx: TypeContext, expected: Int, found: Int, span: Span) -> TypeContext
    if types_equal(ctx, expected, found) then ctx
    else ctx_add_error(ctx, type_error_mismatch(span, type_name(ctx, expected), type_name(ctx, found)))

f infer_index_result(ctx: TypeContext, arr_ty: Int) -> (TypeContext, Int)
    if arr_ty < 0 || arr_ty >= vec_len(ctx.types) then (ctx, IDX_UNKNOWN())
    else
        ty := ctx.types[arr_ty]
        if ty.kind == TY_ARRAY() then (ctx, ty.inner)
        else if ty.kind == TY_STR() then (ctx, IDX_CHAR())
        else (ctx, IDX_UNKNOWN())

# ============================================================================
# Expression Type Inference
# ============================================================================

f infer_expr(ctx: TypeContext, ast: AST, expr_idx: Int) -> (TypeContext, Int)
    if expr_idx < 0 || expr_idx >= vec_len(ast.exprs) then
        (ctx, IDX_UNKNOWN())
    else
        expr := ast.exprs[expr_idx]

        if expr.kind == EXPR_INT() then (ctx, IDX_INT())
        else if expr.kind == EXPR_FLOAT() then (ctx, IDX_FLOAT())
        else if expr.kind == EXPR_BOOL() then (ctx, IDX_BOOL())
        else if expr.kind == EXPR_CHAR() then (ctx, IDX_CHAR())
        else if expr.kind == EXPR_STR() then (ctx, IDX_STR())

        else if expr.kind == EXPR_IDENT() then
            type_idx := ctx_lookup_var(ctx, expr.name)
            if type_idx < 0 then
                err := type_error("undefined variable", expr.span)
                (ctx_add_error(ctx, err), IDX_UNKNOWN())
            else
                (ctx, type_idx)

        else if expr.kind == EXPR_BINARY() then
            infer_binary(ctx, ast, expr)

        else if expr.kind == EXPR_UNARY() then
            infer_unary(ctx, ast, expr)

        else if expr.kind == EXPR_CALL() then
            infer_call(ctx, ast, expr)

        else if expr.kind == EXPR_IF() then
            infer_if(ctx, ast, expr)

        else if expr.kind == EXPR_BLOCK() then
            infer_block(ctx, ast, expr)

        else if expr.kind == EXPR_RETURN() then
            if expr.operand >= 0 then infer_expr(ctx, ast, expr.operand)
            else (ctx, IDX_UNIT())

        else if expr.kind == EXPR_BREAK() || expr.kind == EXPR_CONTINUE() then
            (ctx, IDX_UNIT())

        else if expr.kind == EXPR_WHILE() then
            (ctx2, cond_ty) := infer_expr(ctx, ast, expr.condition)
            ctx3 := check_is_bool(ctx2, cond_ty, expr.span)
            (ctx4, _) := infer_expr(ctx3, ast, expr.body_block)
            (ctx4, IDX_UNIT())

        else if expr.kind == EXPR_ARRAY() then
            infer_array(ctx, ast, expr)

        else if expr.kind == EXPR_TUPLE() then
            infer_tuple(ctx, ast, expr)

        else if expr.kind == EXPR_FIELD() then
            (ctx2, _) := infer_expr(ctx, ast, expr.object)
            (ctx2, IDX_UNKNOWN())

        else if expr.kind == EXPR_INDEX() then
            (ctx2, arr_ty) := infer_expr(ctx, ast, expr.left)
            (ctx3, idx_ty) := infer_expr(ctx2, ast, expr.right)
            ctx4 := check_types_match(ctx3, IDX_INT(), idx_ty, expr.span)
            infer_index_result(ctx4, arr_ty)

        else if expr.kind == EXPR_MATCH() then
            infer_match(ctx, ast, expr)

        else
            (ctx, IDX_UNKNOWN())

# ============================================================================
# Binary/Unary Operation Type Inference
# ============================================================================

f infer_binary(ctx: TypeContext, ast: AST, expr: ExprNode) -> (TypeContext, Int)
    (ctx2, left_ty) := infer_expr(ctx, ast, expr.left)
    (ctx3, right_ty) := infer_expr(ctx2, ast, expr.right)

    op := expr.op

    if op == OP_ADD() || op == OP_SUB() || op == OP_MUL() || op == OP_DIV() || op == OP_REM() then
        if types_equal(ctx3, left_ty, IDX_INT()) && types_equal(ctx3, right_ty, IDX_INT()) then
            (ctx3, IDX_INT())
        else if types_equal(ctx3, left_ty, IDX_FLOAT()) && types_equal(ctx3, right_ty, IDX_FLOAT()) then
            (ctx3, IDX_FLOAT())
        else if op == OP_ADD() && types_equal(ctx3, left_ty, IDX_STR()) && types_equal(ctx3, right_ty, IDX_STR()) then
            (ctx3, IDX_STR())
        else
            err := type_error_mismatch(expr.span, type_name(ctx3, left_ty), type_name(ctx3, right_ty))
            (ctx_add_error(ctx3, err), IDX_UNKNOWN())

    else if op == OP_EQ() || op == OP_NE() || op == OP_LT() || op == OP_LE() || op == OP_GT() || op == OP_GE() then
        if types_equal(ctx3, left_ty, right_ty) then
            (ctx3, IDX_BOOL())
        else
            err := type_error_mismatch(expr.span, type_name(ctx3, left_ty), type_name(ctx3, right_ty))
            (ctx_add_error(ctx3, err), IDX_BOOL())

    else if op == OP_AND() || op == OP_OR() then
        ctx4 := check_is_bool(ctx3, left_ty, expr.span)
        ctx5 := check_is_bool(ctx4, right_ty, expr.span)
        (ctx5, IDX_BOOL())

    else
        (ctx3, IDX_UNKNOWN())

f infer_unary(ctx: TypeContext, ast: AST, expr: ExprNode) -> (TypeContext, Int)
    (ctx2, operand_ty) := infer_expr(ctx, ast, expr.operand)

    op := expr.op

    if op == UNOP_NEG() then
        if types_equal(ctx2, operand_ty, IDX_INT()) then (ctx2, IDX_INT())
        else if types_equal(ctx2, operand_ty, IDX_FLOAT()) then (ctx2, IDX_FLOAT())
        else
            err := type_error("negation requires numeric type", expr.span)
            (ctx_add_error(ctx2, err), IDX_UNKNOWN())

    else if op == UNOP_NOT() then
        if types_equal(ctx2, operand_ty, IDX_BOOL()) then (ctx2, IDX_BOOL())
        else
            err := type_error_mismatch(expr.span, "Bool", type_name(ctx2, operand_ty))
            (ctx_add_error(ctx2, err), IDX_BOOL())

    else
        (ctx2, IDX_UNKNOWN())

# ============================================================================
# Function Call Type Inference
# ============================================================================

f infer_call(ctx: TypeContext, ast: AST, expr: ExprNode) -> (TypeContext, Int)
    if expr.callee < 0 || expr.callee >= vec_len(ast.exprs) then
        (ctx, IDX_UNKNOWN())
    else
        callee := ast.exprs[expr.callee]
        if callee.kind != EXPR_IDENT() then
            (ctx, IDX_UNKNOWN())
        else
            fn_name := callee.name
            maybe_sig := ctx_lookup_fn(ctx, fn_name)
            m maybe_sig
                Some(sig) ->
                    if vec_len(expr.args) != vec_len(sig.param_types) then
                        err := type_error("wrong number of arguments", expr.span)
                        (ctx_add_error(ctx, err), sig.ret_type)
                    else
                        ctx2 := check_args(ctx, ast, expr.args, sig.param_types, 0, expr.span)
                        (ctx2, sig.ret_type)
                None ->
                    ctx2 := check_args_no_sig(ctx, ast, expr.args, 0)
                    (ctx2, IDX_UNKNOWN())

f check_args(ctx: TypeContext, ast: AST, args: [Int], param_types: [Int], idx: Int, span: Span) -> TypeContext
    if idx >= vec_len(args) then ctx
    else
        (ctx2, arg_ty) := infer_expr(ctx, ast, args[idx])
        param_ty := param_types[idx]
        ctx3 := check_types_match(ctx2, param_ty, arg_ty, span)
        check_args(ctx3, ast, args, param_types, idx + 1, span)

f check_args_no_sig(ctx: TypeContext, ast: AST, args: [Int], idx: Int) -> TypeContext
    if idx >= vec_len(args) then ctx
    else
        (ctx2, _) := infer_expr(ctx, ast, args[idx])
        check_args_no_sig(ctx2, ast, args, idx + 1)

# ============================================================================
# If Expression Type Inference
# ============================================================================

f infer_if(ctx: TypeContext, ast: AST, expr: ExprNode) -> (TypeContext, Int)
    (ctx2, cond_ty) := infer_expr(ctx, ast, expr.condition)
    ctx3 := check_is_bool(ctx2, cond_ty, expr.span)
    (ctx4, then_ty) := infer_expr(ctx3, ast, expr.then_branch)
    if expr.else_branch >= 0 then infer_if_else(ctx4, ast, expr, then_ty)
    else (ctx4, then_ty)

f infer_if_else(ctx: TypeContext, ast: AST, expr: ExprNode, then_ty: Int) -> (TypeContext, Int)
    (ctx2, else_ty) := infer_expr(ctx, ast, expr.else_branch)
    ctx3 := check_types_match(ctx2, then_ty, else_ty, expr.span)
    (ctx3, then_ty)

# ============================================================================
# Block Type Inference
# ============================================================================

f infer_block(ctx: TypeContext, ast: AST, expr: ExprNode) -> (TypeContext, Int)
    infer_stmts(ctx, ast, expr.stmts, 0)

f infer_stmts(ctx: TypeContext, ast: AST, stmts: [Int], idx: Int) -> (TypeContext, Int)
    if idx >= vec_len(stmts) then
        (ctx, IDX_UNIT())
    else
        stmt_idx := stmts[idx]
        if stmt_idx < 0 || stmt_idx >= vec_len(ast.stmts) then
            (ctx, IDX_UNIT())
        else
            stmt := ast.stmts[stmt_idx]

            if stmt.kind == STMT_EXPR() then
                (ctx2, ty) := infer_expr(ctx, ast, stmt.expr)
                if idx + 1 >= vec_len(stmts) then (ctx2, ty)
                else infer_stmts(ctx2, ast, stmts, idx + 1)

            else if stmt.kind == STMT_LET() then
                (ctx2, init_ty) := infer_expr(ctx, ast, stmt.init)
                ctx3 := add_let_binding(ctx2, ast, stmt, init_ty)
                infer_stmts(ctx3, ast, stmts, idx + 1)

            else
                infer_stmts(ctx, ast, stmts, idx + 1)

f add_let_binding(ctx: TypeContext, ast: AST, stmt: StmtNode, init_ty: Int) -> TypeContext
    if stmt.pattern < 0 || stmt.pattern >= vec_len(ast.patterns) then ctx
    else
        pat := ast.patterns[stmt.pattern]
        if pat.kind == PAT_IDENT() then ctx_add_var(ctx, pat.name, init_ty) else ctx

# ============================================================================
# Array/Tuple Type Inference
# ============================================================================

f infer_array(ctx: TypeContext, ast: AST, expr: ExprNode) -> (TypeContext, Int)
    if vec_len(expr.elements) == 0 then
        (ctx, IDX_UNKNOWN())
    else
        (ctx2, elem_ty) := infer_expr(ctx, ast, expr.elements[0])
        ctx3 := check_array_elements(ctx2, ast, expr.elements, elem_ty, 1, expr.span)
        arr_ty := ty_array(elem_ty)
        (new_ctx, arr_idx) := ctx_add_type(ctx3, arr_ty)
        (new_ctx, arr_idx)

f check_array_elements(ctx: TypeContext, ast: AST, elements: [Int], expected_ty: Int, idx: Int, span: Span) -> TypeContext
    if idx >= vec_len(elements) then ctx
    else
        (ctx2, elem_ty) := infer_expr(ctx, ast, elements[idx])
        ctx3 := check_types_match(ctx2, expected_ty, elem_ty, span)
        check_array_elements(ctx3, ast, elements, expected_ty, idx + 1, span)

f infer_tuple(ctx: TypeContext, ast: AST, expr: ExprNode) -> (TypeContext, Int)
    (ctx2, elem_types) := infer_tuple_elements(ctx, ast, expr.elements, 0, [])
    tuple_ty := type_new(TY_TUPLE())
    tuple_ty = Type { kind: tuple_ty.kind, name: tuple_ty.name, elements: elem_types, inner: tuple_ty.inner, ok_type: tuple_ty.ok_type, err_type: tuple_ty.err_type, ret_type: tuple_ty.ret_type, var_id: tuple_ty.var_id }
    (new_ctx, tuple_idx) := ctx_add_type(ctx2, tuple_ty)
    (new_ctx, tuple_idx)

f infer_tuple_elements(ctx: TypeContext, ast: AST, elements: [Int], idx: Int, acc: [Int]) -> (TypeContext, [Int])
    if idx >= vec_len(elements) then (ctx, acc)
    else
        (ctx2, elem_ty) := infer_expr(ctx, ast, elements[idx])
        new_acc := vec_push(acc, elem_ty)
        infer_tuple_elements(ctx2, ast, elements, idx + 1, new_acc)

# ============================================================================
# Match Type Inference
# ============================================================================

f infer_match(ctx: TypeContext, ast: AST, expr: ExprNode) -> (TypeContext, Int)
    (ctx2, scrut_ty) := infer_expr(ctx, ast, expr.scrutinee)

    if vec_len(expr.arms) == 0 then (ctx2, IDX_UNKNOWN())
    else
        first_arm_idx := expr.arms[0]
        (ctx3, first_ty) := infer_match_arm_body(ctx2, ast, first_arm_idx)
        ctx4 := check_match_arms(ctx3, ast, expr.arms, first_ty, 1, expr.span)
        (ctx4, first_ty)

f infer_match_arm_body(ctx: TypeContext, ast: AST, arm_idx: Int) -> (TypeContext, Int)
    if arm_idx < 0 || arm_idx >= vec_len(ast.match_arms) then (ctx, IDX_UNKNOWN())
    else
        arm := ast.match_arms[arm_idx]
        infer_expr(ctx, ast, arm.body)

f check_match_arms(ctx: TypeContext, ast: AST, arms: [Int], expected_ty: Int, idx: Int, span: Span) -> TypeContext
    if idx >= vec_len(arms) then ctx
    else
        (ctx2, arm_ty) := infer_match_arm_body(ctx, ast, arms[idx])
        ctx3 := check_types_match(ctx2, expected_ty, arm_ty, span)
        check_match_arms(ctx3, ast, arms, expected_ty, idx + 1, span)

# ============================================================================
# Function Type Checking
# ============================================================================

f register_function(ctx: TypeContext, ast: AST, item: ItemNode) -> TypeContext
    (ctx2, param_types) := convert_params(ctx, ast, item.params, 0, [])
    (ctx3, ret_ty) := convert_ast_type(ctx2, ast, item.return_type)
    sig := FnSig { name: item.name, param_types: param_types, ret_type: ret_ty }
    ctx_add_fn(ctx3, sig)

f convert_params(ctx: TypeContext, ast: AST, params: [(Str, Int)], idx: Int, acc: [Int]) -> (TypeContext, [Int])
    if idx >= vec_len(params) then (ctx, acc)
    else
        (param_name, type_idx) := params[idx]
        (ctx2, ty) := convert_ast_type(ctx, ast, type_idx)
        new_acc := vec_push(acc, ty)
        convert_params(ctx2, ast, params, idx + 1, new_acc)

f convert_ast_type(ctx: TypeContext, ast: AST, type_idx: Int) -> (TypeContext, Int)
    if type_idx < 0 || type_idx >= vec_len(ast.types) then (ctx, IDX_UNKNOWN())
    else
        ty := ast.types[type_idx]
        if ty.kind == TYPE_NAMED() then
            name := ty.name
            if name == "Int" then (ctx, IDX_INT())
            else if name == "Float" then (ctx, IDX_FLOAT())
            else if name == "Bool" then (ctx, IDX_BOOL())
            else if name == "Char" then (ctx, IDX_CHAR())
            else if name == "Str" then (ctx, IDX_STR())
            else
                named_ty := ty_named(name)
                ctx_add_type(ctx, named_ty)
        else (ctx, IDX_UNKNOWN())

f check_function(ctx: TypeContext, ast: AST, item: ItemNode) -> TypeContext
    (ctx2, ret_ty) := convert_ast_type(ctx, ast, item.return_type)
    ctx3 := add_params_to_env(ctx2, ast, item.params, 0)
    (ctx4, body_ty) := infer_expr(ctx3, ast, item.body)

    if item.return_type >= 0 && !types_equal(ctx4, body_ty, ret_ty) then
        err := type_error_mismatch(item.span, type_name(ctx4, ret_ty), type_name(ctx4, body_ty))
        ctx_add_error(ctx4, err)
    else ctx4

f add_params_to_env(ctx: TypeContext, ast: AST, params: [(Str, Int)], idx: Int) -> TypeContext
    if idx >= vec_len(params) then ctx
    else
        (param_name, type_idx) := params[idx]
        (ctx2, ty) := convert_ast_type(ctx, ast, type_idx)
        ctx3 := ctx_add_var(ctx2, param_name, ty)
        add_params_to_env(ctx3, ast, params, idx + 1)

# ============================================================================
# Main Type Checking Entry Point
# ============================================================================

f type_check(ast: AST) -> (TypeContext, Bool)
    ctx := ctx_new()
    ctx2 := register_all_functions(ctx, ast, 0)
    ctx3 := check_all_functions(ctx2, ast, 0)
    has_errors := vec_len(ctx3.errors) > 0
    (ctx3, !has_errors)

f register_all_functions(ctx: TypeContext, ast: AST, idx: Int) -> TypeContext
    if idx >= vec_len(ast.items) then ctx
    else
        item := ast.items[idx]
        ctx2 := register_fn_if_fn(ctx, ast, item)
        register_all_functions(ctx2, ast, idx + 1)

f register_fn_if_fn(ctx: TypeContext, ast: AST, item: ItemNode) -> TypeContext
    if item.kind == ITEM_FN() then register_function(ctx, ast, item) else ctx

f check_all_functions(ctx: TypeContext, ast: AST, idx: Int) -> TypeContext
    if idx >= vec_len(ast.items) then ctx
    else
        item := ast.items[idx]
        ctx2 := check_fn_if_fn(ctx, ast, item)
        check_all_functions(ctx2, ast, idx + 1)

f check_fn_if_fn(ctx: TypeContext, ast: AST, item: ItemNode) -> TypeContext
    if item.kind == ITEM_FN() then check_function(ctx, ast, item) else ctx

# ============================================================================
# Error Formatting
# ============================================================================

f format_errors(ctx: TypeContext) -> Str
    format_errors_loop(ctx.errors, 0, "")

f format_errors_loop(errors: [TypeError], idx: Int, acc: Str) -> Str
    if idx >= vec_len(errors) then acc
    else
        err := errors[idx]
        format_errors_loop(errors, idx + 1, err.message)

f print_error(err: TypeError) -> Int
    print(err.message)
    0

# ============================================================================
# Test - Simple type checking
# ============================================================================

f main() -> Int
    # Test: create a simple AST and type check it
    # For now, just return success
    42
